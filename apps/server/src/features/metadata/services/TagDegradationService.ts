/**
 * Tag Degradation Service - Manages automatic tag expiration and rule relevance decay
 */

import type { DatabaseManager } from '../../storage/DatabaseManager.js';
import { logger } from '../../../shared/logger.js';
import type { INote, ITask, IRule } from '@felix/code-intelligence';
import { createHash } from 'crypto';
import { readFileSync } from 'fs';

export interface DegradationConfig {
  autoTagMaxAge: number;           // Days before auto_tags expire
  contextualTagMaxAge: number;     // Days before contextual_tags expire  
  ruleDecayRate: number;          // Daily decay rate for rule usage (0.01 = 1% per day)
  inactiveRuleThreshold: number;  // Days without use before rule marked for review
  cleanupInterval: number;        // Hours between cleanup runs
  preserveUserTags: boolean;      // Never remove stable_tags
}

export interface FileHashRecord {
  file_path: string;
  hash: string;
  last_modified: Date;
  linked_entities: Array<{
    entity_type: string;
    entity_id: string;
  }>;
}

export interface DegradationStats {
  expired_auto_tags: number;
  expired_contextual_tags: number;
  decayed_rules: number;
  inactive_rules: number;
  broken_file_links: number;
  cleanup_duration: number;
}

export class TagDegradationService {
  private config: DegradationConfig;
  private dbManager: DatabaseManager;

  constructor(dbManager: DatabaseManager, config: Partial<DegradationConfig> = {}) {
    this.dbManager = dbManager;
    this.config = {
      autoTagMaxAge: 30,           // 30 days
      contextualTagMaxAge: 14,     // 14 days  
      ruleDecayRate: 0.02,         // 2% per day
      inactiveRuleThreshold: 90,   // 90 days
      cleanupInterval: 24,         // 24 hours
      preserveUserTags: true,
      ...config
    };
  }

  /**
   * Run complete degradation cleanup process
   */
  async runDegradation(): Promise<DegradationStats> {
    const startTime = Date.now();
    const stats: DegradationStats = {
      expired_auto_tags: 0,
      expired_contextual_tags: 0,
      decayed_rules: 0,
      inactive_rules: 0,
      broken_file_links: 0,
      cleanup_duration: 0
    };

    logger.info('Starting tag degradation cleanup...');

    try {
      // 1. Expire auto_tags based on file changes
      stats.expired_auto_tags = await this.expireAutoTags();

      // 2. Expire contextual_tags based on age
      stats.expired_contextual_tags = await this.expireContextualTags();

      // 3. Decay rule relevance scores
      stats.decayed_rules = await this.decayRuleRelevance();

      // 4. Mark inactive rules for review
      stats.inactive_rules = await this.markInactiveRules();

      // 5. Clean up broken file links
      stats.broken_file_links = await this.cleanupBrokenFileLinks();

      stats.cleanup_duration = Date.now() - startTime;

      logger.info(`Degradation complete: ${JSON.stringify(stats)}`);
      return stats;

    } catch (error) {
      logger.error('Degradation failed:', error);
      throw error;
    }
  }

  /**
   * Expire auto_tags when linked files have changed
   */
  private async expireAutoTags(): Promise<number> {
    let expiredCount = 0;

    try {
      // Get all entities with auto_tags
      const [notes, tasks, rules] = await Promise.all([
        this.getAllNotes(),
        this.getAllTasks(), 
        this.getAllRules()
      ]);

      const allEntities = [
        ...notes.map(n => ({ ...n, entity_type: 'note' })),
        ...tasks.map(t => ({ ...t, entity_type: 'task' })),
        ...rules.map(r => ({ ...r, entity_type: 'rule' }))
      ];

      for (const entity of allEntities) {
        if (!('stable_tags' in entity) || !entity.stable_tags) continue;

        const entityWithTags = entity as typeof entity & { stable_tags: string[] };

        const autoTags = entityWithTags.stable_tags.filter((tag: string) => 
          tag.startsWith('auto:') || this.isAutoGeneratedTag(tag)
        );

        if (autoTags.length === 0) continue;

        // Check if any linked files have changed
        const hasChangedFiles = await this.hasLinkedFilesChanged(entity);
        
        if (hasChangedFiles) {
          const newTags = entityWithTags.stable_tags.filter((tag: string) => 
            !autoTags.includes(tag)
          );

          await this.updateEntityTags(entity.entity_type, entity.id, newTags);
          expiredCount += autoTags.length;

          logger.debug(`Expired ${autoTags.length} auto tags from ${entity.entity_type}:${entity.id}`);
        }
      }

    } catch (error) {
      logger.warn('Failed to expire auto tags:', error);
    }

    return expiredCount;
  }

  /**
   * Expire contextual_tags based on age
   */
  private async expireContextualTags(): Promise<number> {
    let expiredCount = 0;

    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - this.config.contextualTagMaxAge);

      // Get all entities with contextual tags older than threshold
      const [notes, tasks] = await Promise.all([
        this.getAllNotes(),
        this.getAllTasks()
      ]);

      const allEntities = [
        ...notes.map(n => ({ ...n, entity_type: 'note' })),
        ...tasks.map(t => ({ ...t, entity_type: 'task' }))
      ];

      for (const entity of allEntities) {
        if (!('stable_tags' in entity) || !entity.stable_tags || !entity.updated_at) continue;

        const entityWithTags = entity as typeof entity & { stable_tags: string[] };

        const entityDate = new Date(entity.updated_at);
        if (entityDate > cutoffDate) continue;

        const contextualTags = entityWithTags.stable_tags.filter((tag: string) => 
          tag.startsWith('context:') || this.isContextualTag(tag)
        );

        if (contextualTags.length > 0) {
          const newTags = entityWithTags.stable_tags.filter((tag: string) => 
            !contextualTags.includes(tag)
          );

          await this.updateEntityTags(entity.entity_type, entity.id, newTags);
          expiredCount += contextualTags.length;

          logger.debug(`Expired ${contextualTags.length} contextual tags from ${entity.entity_type}:${entity.id}`);
        }
      }

    } catch (error) {
      logger.warn('Failed to expire contextual tags:', error);
    }

    return expiredCount;
  }

  /**
   * Decay rule relevance scores based on usage
   */
  private async decayRuleRelevance(): Promise<number> {
    let decayedCount = 0;

    try {
      const rules = await this.getAllRules();
      
      for (const rule of rules) {
        if (!rule.last_used || !rule.usage_count) continue;

        const lastUsed = new Date(rule.last_used);
        const daysSinceUsed = Math.floor((Date.now() - lastUsed.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysSinceUsed > 0) {
          // Apply exponential decay
          const decayFactor = Math.pow(1 - this.config.ruleDecayRate, daysSinceUsed);
          const newUsageCount = Math.max(0, Math.floor(rule.usage_count * decayFactor));

          if (newUsageCount !== rule.usage_count) {
            await this.updateRuleUsage(rule.id, newUsageCount);
            decayedCount++;

            logger.debug(`Rule ${rule.id} usage decayed: ${rule.usage_count} -> ${newUsageCount}`);
          }
        }
      }

    } catch (error) {
      logger.warn('Failed to decay rule relevance:', error);
    }

    return decayedCount;
  }

  /**
   * Mark rules as inactive if not used for threshold period
   */
  private async markInactiveRules(): Promise<number> {
    let inactiveCount = 0;

    try {
      // Use the new analytics-based approach for rule degradation
      const rulesForDegradation = await this.getRulesForDegradation();
      
      for (const rule of rulesForDegradation) {
        // Mark rule as inactive
        await this.markRuleInactive(rule.id);
        inactiveCount++;
        logger.info(`Rule ${rule.id} marked inactive due to low usage/effectiveness`);
      }

    } catch (error) {
      logger.warn('Failed to mark inactive rules:', error);
    }

    return inactiveCount;
  }

  /**
   * Get rules that should be marked for degradation using analytics
   */
  private async getRulesForDegradation(): Promise<IRule[]> {
    try {
      // Check if database manager has getRulesRepository method
      if (!this.dbManager || !('getRulesRepository' in this.dbManager)) {
        return [];
      }

      const rulesManager = this.dbManager.getRulesRepository();
      if (!rulesManager || !('getRulesForDegradation' in rulesManager)) {
        // Fallback to old method
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - this.config.inactiveRuleThreshold);
        const rules = await this.getAllRules();
        return rules.filter(rule => {
          if (!rule.active) return false;
          
          const lastUsed = rule.last_used ? new Date(rule.last_used) : null;
          const isOld = !lastUsed || lastUsed < cutoffDate;
          const hasLowEffectiveness = (rule.effectiveness_score || 0) < 0.3;
          
          return isOld || hasLowEffectiveness;
        });
      }

      // Use the new analytics-based method
      return await rulesManager.getRulesForDegradation(
        this.config.inactiveRuleThreshold,
        0.3 // Low effectiveness threshold
      );

    } catch (error) {
      logger.warn('Failed to get rules for degradation:', error);
      return [];
    }
  }

  /**
   * Clean up broken file links in entity links
   */
  private async cleanupBrokenFileLinks(): Promise<number> {
    let brokenCount = 0;

    try {
      // This would need to be implemented based on the entity linking system
      // For now, just a placeholder that could check if linked files still exist
      logger.info('File link cleanup not yet implemented');

    } catch (error) {
      logger.warn('Failed to cleanup broken file links:', error);
    }

    return brokenCount;
  }

  /**
   * Check if linked files have changed since last check
   */
  private async hasLinkedFilesChanged(entity: any): Promise<boolean> {
    if (!entity.entity_links) return false;

    try {
      for (const link of entity.entity_links) {
        if (link.entity_type === 'file' && link.entity_id) {
          const filePath = link.entity_id;
          
          try {
            const currentHash = this.calculateFileHash(filePath);
            const storedHash = await this.getStoredFileHash(filePath);
            
            if (storedHash && currentHash !== storedHash) {
              await this.updateFileHash(filePath, currentHash);
              return true;
            }
          } catch (error) {
            // File might not exist anymore
            return true;
          }
        }
      }
    } catch (error) {
      logger.warn('Error checking file changes:', error);
    }

    return false;
  }

  /**
   * Calculate hash of file content
   */
  private calculateFileHash(filePath: string): string {
    try {
      const content = readFileSync(filePath, 'utf8');
      return createHash('md5').update(content).digest('hex');
    } catch (error) {
      throw new Error(`Cannot read file: ${filePath}`);
    }
  }

  /**
   * Check if tag is auto-generated
   */
  private isAutoGeneratedTag(tag: string): boolean {
    return tag.startsWith('auto:') || 
           tag.startsWith('lang:') ||
           tag.startsWith('type:') ||
           tag.includes('generated');
  }

  /**
   * Check if tag is contextual
   */
  private isContextualTag(tag: string): boolean {
    return tag.startsWith('context:') ||
           tag.startsWith('location:') ||
           tag.includes('session') ||
           tag.includes('temp');
  }

  // Helper methods for database operations
  private async getAllNotes(): Promise<INote[]> {
    const result = await this.dbManager.getNotesRepository().searchNotes({});
    return result.items;
  }

  private async getAllTasks(): Promise<ITask[]> {
    const result = await this.dbManager.getTasksRepository().searchTasks({});
    return result.items;
  }

  private async getAllRules(): Promise<IRule[]> {
    const result = await this.dbManager.getRulesRepository().getAllRules(true); // Include inactive
    return result;
  }

  private async updateEntityTags(entityType: string, entityId: string, tags: string[]): Promise<void> {
    const updates = { stable_tags: tags };
    
    switch (entityType) {
      case 'note':
        await this.dbManager.getNotesRepository().updateNote(entityId, updates);
        break;
      case 'task':
        await this.dbManager.getTasksRepository().updateTask(entityId, updates);
        break;
      case 'rule':
        await this.dbManager.getRulesRepository().updateRule(entityId, updates);
        break;
    }
  }

  private async updateRuleUsage(ruleId: string, usageCount: number): Promise<void> {
    await this.dbManager.getRulesRepository().updateRule(ruleId, { usage_count: usageCount });
  }

  private async markRuleInactive(ruleId: string): Promise<void> {
    await this.dbManager.getRulesRepository().updateRule(ruleId, { active: false });
  }

  private async getStoredFileHash(filePath: string): Promise<string | null> {
    // This would need to be implemented with a file_hashes table
    // For now, return null to skip hash checking
    return null;
  }

  private async updateFileHash(filePath: string, hash: string): Promise<void> {
    // This would need to be implemented with a file_hashes table
    // For now, just log
    logger.debug(`File hash updated: ${filePath} -> ${hash}`);
  }
}
